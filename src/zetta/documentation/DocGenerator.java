package zetta.documentation;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.LinkedList;

import zetta.Zetta;
import zetta.exception.InterpreterErrorException;
import zetta.lang.Construct;
import zetta.lang.DataType;
import zetta.lang.Method;
import zetta.lang.method.file.MethodFileClearDir;
import zetta.lang.util.FileFormat;
import zetta.library.Library;

/**
 * 
 * @author samueltebbs, 20:27:37 - 4 Sep 2014
 */
public class DocGenerator {

    public static String DIR_FORMATS = "_file_formats",
	    DIR_CONSTRUCTS = "_constructs";
    public static final String BRACKET_PADDING = " ", LINE_WIDTH = "600";

    public static final String HTML_CODE_OPEN = FileFormat.HTML_CODE_TAG_OPEN,
	    HTML_CODE_CLOSE = FileFormat.HTML_CODE_TAG_CLOSE;

    public static String libLink = "";

    public static void start() {
	final File docsDir = new File("docs");
	if (docsDir.exists()) {
	    MethodFileClearDir.deleteRecursive(docsDir);
	}
	makeDir(docsDir);
	for (final Library lib : Zetta.libraries) {
	    final File libDir = newDir(lib.libFolderName, docsDir);
	    final File indexF = newFile("index.html", libDir);
	    final PrintWriter pw = openHTML(indexF);
	    title(lib.libName, pw);
	    libLink = "<a href=\"../index.html\">" + lib.libName + "</a>";
	    pw.write(lib.libDesc + "\n");
	    dataTypes(lib, pw, libDir, pw);
	    methods(lib, pw);
	    constructs(lib, pw, libDir);
	    fileFormats(lib, pw, libDir);
	    pw.write("\n</body>");
	    closeHTML(pw);
	}
    }

    private static void constructs(final Library lib, final PrintWriter pw,
	    final File libDir) {
	if (lib.constructs.size() > 0) {
	    pw.write("<h2>Constructs</h2>");
	    pw.write("<ul>");
	    final File conDir = newDir(DIR_CONSTRUCTS, libDir);
	    for (final Construct c : lib.constructs) {
		pw.write("<li><a href=\"" + DIR_CONSTRUCTS + "/" + c.name
			+ ".html\">" + c.name + "</a></li>");
		final PrintWriter conP = openHTML(newFile(c.name + ".html",
			conDir));
		title(c.name, conP);
		final int length = Math.max(Math.max(c.docArguments().length,
			c.docDescriptions().length), c.docThrows().length);
		for (int k = 0; k < length; k++) {
		    String desc = "";
		    if ((k >= c.docDescriptions().length)
			    && (c.docDescriptions().length >= 1)) {
			desc = c.docDescriptions()[c.docDescriptions().length - 1];
		    }
		    if (k < c.docDescriptions().length) {
			desc = c.docDescriptions()[k];
		    }
		    conP.write(desc + "<br><br>");
		}
		conP.write("</body>");
		closeHTML(conP);
	    }
	    pw.write("</ul>");
	}
    }

    private static void fileFormats(final Library lib, final PrintWriter pw,
	    final File libDir) {
	if (lib.fileFormats.size() == 0) return;
	pw.write("<br><h2>File Formats</h2>\n<ul>\n");
	final File formatsDir = newDir(DIR_FORMATS, libDir);
	formatsDir.mkdir();
	for (final FileFormat f : lib.fileFormats) {
	    pw.write("<li><a href=\"" + DIR_FORMATS + "/" + f.name + ".html\">"
		    + f.name + "</a></li>\n");
	    final PrintWriter fPw = openHTML(newFile(f.name + ".html",
		    formatsDir));
	    title(f.name, fPw);
	    fPw.write(f.docInfo());
	    fPw.write("</body>");
	    closeHTML(fPw);
	}
	pw.write("</ul>\n");
    }

    private static void methods(final Library lib, final PrintWriter pw) {
	pw.write("<h2>Methods</h2>\n<ul>");
	pw.write("<li>\n<h3>Standard</h3></li>\n");
	pw.write("<ul>\n");
	for (final Method m : lib.methods) {
	    if (m.pointerMode.equals(Method.POINTER_STANDARD)) {
		pw.write("<li>" + m.name + "</li>\n");
	    }
	}
	pw.write("</ul>\n");

	pw.write("<li>\n<h3>Abstract</h3></li>\n");
	pw.write("<ul>\n");
	for (final Method m : lib.methods) {
	    if (m.pointerMode.equals(Method.POINTER_ABSTRACT)) {
		pw.write("<li>" + m.name + "</li>\n");
	    }
	}
	pw.write("</ul>\n");
	pw.write("</ul>\n");
    }

    private static void title(final String name, final PrintWriter pw) {
	String title = name;
	if (!libLink.equals("")) {
	    title = libLink + ":" + title;
	}
	pw.write("<head>\n");
	pw.write("<title>" + title + "</title>\n");
	pw.write("</head>\n");
	pw.write("<body>\n");
	pw.write("<h1><center>"
		+ title
		+ "</center></h1>\n<center>Docs generated by ZettaDocGen</center>");
	pw.write("\n<hr style=\"background:#000000; height:5px\">\n<br>");
    }

    @SuppressWarnings("rawtypes")
    private static void dataTypes(final Library lib, final PrintWriter pw,
	    final File libDir, final PrintWriter libIndex) {
	if (lib.dataTypes.size() == 0) return;
	pw.write("<br><h2>Data Types and Packages</h2>\n<ul>\n");
	for (final DataType d : lib.dataTypes) {
	    final LinkedList<Method> methods = new LinkedList<Method>();
	    final LinkedList<Method> packageMethods = new LinkedList<Method>();
	    for (final Method m : lib.methods) {
		if (m.pointerDType.equals(d.name)) {
		    if (m.pointerMode.equals(Method.POINTER_SPECIFIC)) {
			methods.add(m);
		    } else if (m.pointerMode.equals(Method.POINTER_PACKAGE)) {
			packageMethods.add(m);
		    }
		}
	    }
	    pw.write("<li><a href=\"" + d.name + "/index.html\">" + d.name
		    + "</a></li>\n");
	    final File typeDir = newDir(d.name, libDir);
	    final File typeF = newFile("index.html", typeDir);
	    final PrintWriter typePw = openHTML(typeF);
	    title(d.name, typePw);
	    typePw.write(d.docDescription() + "\n<br><br>");
	    typePw.write(d.docExtraInfo());
	    String implStr = "";
	    final Class[] interfaces = d.getClass().getInterfaces();
	    for (int c = 0; c < interfaces.length; c++) {
		implStr += interfaces[c].getSimpleName();
		if ((c + 1) < interfaces.length) {
		    implStr += ", ";
		}
	    }
	    if (!implStr.equals("")) {
		typePw.write("<br><b>Implements</b>: " + implStr);
	    }
	    if (d.canBeInstantiated()) {
		typePw.write("<h2>Constructor</h2>\n");
		final int length = Math.min(d.constructArgs().length,
			d.constructDesc().length);
		for (int c = 0; c < length; c++) {
		    String argsStr = "";
		    final String[] args = d.constructArgs()[c];
		    for (int k = 0; k < args.length; k++) {
			argsStr += args[k];
			if ((k + 1) < args.length) {
			    argsStr += ", ";
			}
		    }
		    typePw.write("<b>" + d.name + "</b>(" + BRACKET_PADDING
			    + argsStr + BRACKET_PADDING + ")<br><br>\n");
		    typePw.write(d.constructDesc()[c] + "<br><br>\n");
		}
	    } else {
		typePw.write("Cannot be instantiated<br>\n");
	    }
	    typePw.write("<h2>Methods</h2>\n<ul>");
	    for (final Method m : methods) {
		typePw.write("<li><a href=\"#" + m.name + "\">" + m.name
			+ "</a></li>\n");
	    }
	    for (final Method m : packageMethods) {
		typePw.write("<li><a href=\"#" + d.name + "." + m.name + "\">"
			+ d.name + "." + m.name + "</a></li>\n");
	    }

	    // Add full method descriptions

	    if (d.canBeInstantiated()) {
		// string()
		typePw.write("</ul><br>\n");
		typePw.write("<hr width=\"" + LINE_WIDTH
			+ "\" align=\"LEFT\"><br>");

		typePw.write("String &nbsp;&nbsp;&nbsp;&nbsp; <b>string()</b><br><br>");
		typePw.write(d.stringDesc() + "<br><br>\n");

		typePw.write("<hr width=\"" + LINE_WIDTH + "\" align=\"LEFT\">");
		// size()
		typePw.write("</ul><br>\n");
		typePw.write("Num &nbsp;&nbsp;&nbsp;&nbsp; <b>size()</b><br><br>");
		typePw.write(d.sizeDesc() + "<br><br>\n");
	    }
	    printPackageMethods(methods, typePw, "");
	    printPackageMethods(packageMethods, typePw, d.name + ".");
	    typePw.write("</body>");
	    closeHTML(typePw);
	}
	pw.write("</ul>\n");
    }

    private static void printPackageMethods(final LinkedList<Method> methods,
	    final PrintWriter typePw, final String namePrefix) {
	for (final Method m : methods) {
	    final String name = namePrefix + m.name;
	    final int length = Math.min(Math.min(m.docArguments().length,
		    m.docReturnTypes().length), m.docDescriptions().length);
	    for (int c = 0; c < length; c++) {
		typePw.write("<hr width=\"" + LINE_WIDTH
			+ "\" align=\"LEFT\"><br>");
		String argsStr = "";
		final String[] args = m.docArguments()[c];
		String example = null;
		if (m.docCodeExamples().length > c) {
		    example = m.docCodeExamples()[c];
		}
		for (int k = 0; k < args.length; k++) {
		    argsStr += args[k];
		    if ((k + 1) < args.length) {
			argsStr += ", ";
		    }
		}
		typePw.write("<a name=\"" + name + "\"/>"
			+ m.docReturnTypes()[c]
			+ "&nbsp;&nbsp;&nbsp;&nbsp; <b>" + name + "</b>("
			+ BRACKET_PADDING + argsStr + BRACKET_PADDING + ")");
		if (m.docThrows().length > c) {
		    final String throwStr = Arrays.toString(m.docThrows()[c]);
		    typePw.write("&nbsp;&nbsp;&nbsp;&nbsp;<b>throws</b> "
			    + throwStr.substring(1, throwStr.length() - 1));
		}
		typePw.write("<br><br>\n");
		typePw.write(m.docDescriptions()[c] + "<br><br>\n");
		if (example != null) {
		    typePw.write(example + "<br><br>");
		}
	    }
	}
    }

    private static void makeDir(final File f) {
	if (!f.exists() || !f.isDirectory()) {
	    f.mkdir();
	}
    }

    private static void makeFile(final File f) {
	if (!f.exists() || !f.isFile()) {
	    try {
		f.createNewFile();
	    } catch (final IOException e) {
		new InterpreterErrorException(e);
	    }
	}
    }

    public static File newFile(final String name, final File parent) {
	final File f = new File(parent + File.separator + name);
	makeFile(f);
	return f;
    }

    public static File newFile(final String name) {
	final File f = new File(name);
	makeFile(f);
	return f;
    }

    private static File newDir(final String name, final File parent) {
	final File f = new File(parent + File.separator + name);
	makeDir(f);
	return f;
    }

    private static PrintWriter openHTML(final File f) {
	makeFile(f);
	try {
	    final PrintWriter pw = new PrintWriter(f);
	    pw.write("<html>\n");
	    return pw;
	} catch (final FileNotFoundException e) {
	    new InterpreterErrorException(e);
	}
	return null;
    }

    private static void closeHTML(final PrintWriter pw) {
	pw.write("\n</html>");
	pw.close();
    }

}
